The code in computer programs is made of aka STATEMENTS. 
Statements are the instructions for the computer to follow. 
Real programs can contain thousands of statements.

DECLARING VARIABLES

Variables have a name and a value.
To aka DECLARE a variable be use an equal sign.

movie_name = "The Rocky Horror Picture Show"
movie_year = 1975

DATA TYPES

- Strings: text
- Integers: whole numbers without a decimal point. Negative, positive or zero.
- Float: numbers with decimal places, they can be positive or negative. 
 - The division of two integers always produces a float. 
 - Math operations between integers and floats produce a float.
- Boolean: two possible values: True or False

a = 4
b = 2
c = 4/2
print(c) #displays the result
print(type(c)) #displays data type which will be float

STRINGS

In Python, both single ' and double " quotes can be used to define strings. 
It doesn’t make a difference whether you choose double or single quotation marks, but they do need to match.

Anything in quotation marks will be treated as a string, even numbers.

movie = "Gladiator"
book = "1984"

CONCATENATION

When you use the + addition operator with string values the two strings are joined together. 

This is known as concatenation.

You can't concatenate a string with an integer or float.

#Displays IronMan
print("Iron" + "Man")

#Displays basketball
a = "basket"
b = "ball"
print(a + b)

NUMERICAL DATA

Numerical data shouldn't be in quotation marks. The line of code below declares a numerical variable

price = 10

You can perform math operations with numbers. Each print() instruction will add a value to the screen in a new line.

print(7 + 3)

The computer reads and executes instructions line by line, from top to bottom. 
The execution of the program will be interrupted at the first error encountered.


PRINT()

The print() instruction is the easiest way to send a message to the screen or other display device.

print("Hello world.")

Numbers don't require quotation marks.

print(42)

The print() function accepts arguments of any data type.

print("James", 36, 3.8, True) #Displays James 36 3.8 True

Arguments must be sepparated by commas.

---

print() can also be used with lists.

shopping_list = ["Milk", "Tea", "Onions"]
print(shopping_list) #Display ['Milk', 'Tea', 'Onions']

---

Print() can also be used to print several lines of text by using three sets of double quotes to start and end.

print("""
This is line 1
This line 2
This is line 3
""")

VARIABLE

Computer programs use variables to store important information, like items in a shopping cart, prices and discounts.

The line of code below tells the computer to store information in a variable called item.

This is called "declaring a variable".

Once a variable has been declared, you can aka CALL it as many times as you want.

Spaces are not allowed in variable names in Python. Asterisks (*) aren't either.

A variable name can contain numbers but cannot start with a number.

item = "bike"
name_of_variable = "value"

A variable name can contain numbers but cannot start with a number.

Variables have a name and a value. They are connected with the equal sign =.

A variable’s name is used to identify where that information is stored. 
You can access the value that a variable is storing by calling its name.

budget = 200
print(budget)

budget = 20
print(budget + 10)

price = 5
amount = 3
total = price * amount

You can update the value stored in a variable. The variable will forget the previously stored value.
Updating the value of a variable is called REASSIGING A VARIABLE (aka).

price = 99
price = 100
print(price)

COMMENTS

Professional developers use comments to add descriptions and explanations to their programs.

You can add comments to your Python code with the hash symbol #

#Displaying a message
print("Insufficient funds")

You can use comments to temporarily disable a statement. This way the computer will skip the instruction.

CASE-SENSITIVE

Python is a case-sensitive language, meaning "A" and "a" are treated as different.

credit = 300
Credit = 280
CREDIT = 320

SNAKE CASE

Snake case is a popular way to create variable names in a consistent way. 
Snake case uses underscores _ to separate words in a variable name.

name_username = "John Doe"

Snake case is the best practice for naming variables in Python.

INPUT()

An input is any information that goes into a computer.

The press of a key and the click of a button are examples of inputs.

The input() instruction is the easiest way to allow a user to insert a value into your program.

#Display a window that asks you to write an input
#message's value will be whatever you write in that window
message = input()
print(message)

#Ask user for their age
age = input()

The input() instruction always turns the user input into a string, no matter what the user enters.

birth_year=input() #takes an input
print(type(birth_year)) #displays the data type which will be str

OUTPUT

An output is a way for the computer to communicate with the outside world. 
A message displayed on the screen and the sound from a speaker are examples of outputs.

The print() instruction, which you already know, is the easiest way to get your computer program to generate an output.

TYPE()

Data can come to you in the incorrect format. You can use the type() instruction to check the data type stored in a variable.

city = "Berlin" #stores a string
age = 42 #stores an integer
balance = 830.29 #stores a float
print(type(city)) #outputs <class 'str'>
print(type(age)) #outputs <class 'int'>
print(type(balance)) #outputs <class 'float'>

DATA CONVERSION

DATA CONVERSION / INT()

The int() instruction converts any type of value into an integer

x = "55" # x is a string
y = int(x) # y is an integer

You can use the int() instruction to convert the user input into an integer

# User input is converted into an integer
height = int(input()) 
print(type(height))
# The line above is an effective way to combine 2 instructions into one

DATA CONVERSION / FLOAT()

There are situations when you need values to be treated as floats.

The float() instruction converts values into floats.

a = 3
b = float(a)
print(b) #Will display 3.0

DATA CONVERSION / STR()

In a similar way, you can ensure that values are converted into strings with the str() instruction.

a = 3
b = str(a)
print(type(b)) #print type str

str() helps you concatenate two variables.

name = "Tom"
age = 33
print(name + str(age))

DATA CONVERSION / BOOL()

The function 'bool()' will turn a string into a "True" value unless it's empty.

To get around that, you can do the following:

student = input("Are you a student? y/n")
student_boolean = student == "y"

EXPLICIT AND IMPLICIT CONVERSION

The int(), str() and float() instructions are examples of explicit conversion, which means they are performed by an instruction given by a programmer (like you).

On the other hand, run the code to see some examples of implicit (automatic) data type conversions

# Examples of automatic data type conversion

x = 5 # integer
y = 2 # integer
z = x/y # float (implicit conversion)
print(z)

a = 3 # integer
b = 1.5 # float
c = a + b # float
print(c)

EXERCISE

# Asks the user to enter the savings
savings = input()

# Convert the user input into a float value and update the variable
savings = float(savings)

# Savings grow after 1 year at a 5% annual interest rate
balance = savings * 1.05 

# Convert the balance into a string and update the variable
balance = str(balance)

# Concatenate the 2 strings to produce a message
message = "Amount in 1 year: " +  balance

# Display the message
print(message)

--

# Convert the values into numbers
wins = int(input())
ties = int(input())

# 1 win = 3 points
# 1 tie = 1 point 
# Calculate the score
score = wins * 3 + ties

# Concatenate the 2 strings to produce a message
message = "Score: " + str(score)

# Display the message
print(message)

COMPARISON OPERATIONS / BOOLEAN DATA TYPES

A comparison operation always results in either one of these two outcomes: True or False

The result of a comparison is always a boolean.

print(type(5 < 9)) #Displays <class 'bool'>

#Compares 5 and 9 and returns true because 5 is smaller than 9
print(5 < 9)

#Tells you whether 40 is bigger or equal to 40
print(40 >= 40)

#Tells you whether a is equal to b
a = 4
b = 5
print(a == b)

#Tells you if variables a and b are not equal
a = 4
b = 5
print(a != b)

You can store booleans values in variables like you do with other data types.

passed_exam = True

You can store the result of a comparison operation as a variable.

peak_rate = heart_rate > 160

#Will print True 
heart_rate = 165
peak_rate = heart_rate > 160
print(peak_rate)

LOGICAL OPERATIONS 

A logical operation takes several boolean inputs and produces 1 boolean output.

- The "and" operation results in a True value only when all the inputs are True at the same time. 
- The "or" logical operation results in a True value if at least one of the inputs is True.

Logical operations need to be inserted in print() instructions for the result to be outputted.

print(True and False)
print(False and True)
print(True or False)
print(False or True)

Python is a case-sensitive language. 

- Both "True" and "False" start with an uppercase letter.
- Both "and" and "or" operators are lowercase in Python. 

You can put parentheses around the operations that should be done first. It makes the code easier to read.

#variable value is True because 3 > 2
a = (3 > 2) or False

CONTROL FLOW

In this lesson, you'll learn to control the flow of instructions a computer follows, using 3 techniques: sequencing, iteration and selection.

- SEQUENCING: computer runs your code in order, from top to bottom.
- ITERATION: is about executing an instruction repeatedly. Iteration is commonly represented as a loop.
- SELECTION: specifies when to follow each path.

An algorithm is a set of step-by-step instructions to complete a task, placed in a certain order.

Flowcharts help to visualize algorithms.

Another way to represent an algorithm is with pseudocode. 
Pseudocode is a simplified language that is a bit closer to a programming language.

ITERATION / FOR

Iteration is used to automate tasks that need to be done over and over again. 

Iteration makes your programs simpler, faster and reduces errors.

The for loop begins with the keyword "for".

The initial loop statement must be followed by a colon : symbol. This signals the start of the iteration block.

for i in range(3):
  print("Hello")

You need an internal variable for the loop, which can be "i", "potato", or anything else.

#Define the number of iterations
for i in range(3):
  #Statement that gets repeated
  print("Hello")

# Loop using i as internal variable
for i in range(3):
  print(i)
print("--")   #This is just a separator
#Loop using "something" as internal variable
for something in range(3):
  print(something)

#Displays 3 booleans
for i in range(3):
  print(i < 1)

The code that gets repeated in the for loop must be indented. Indentation is the spaces at the beginning of lines.

Python doesn't mind whether you use 2 spaces or 4 spaces (or any other number of spaces) or tabs as long as 
you use the same indentation with every loop.

ITERATION / RANGE()

"range()" generates a sequence of x numbers, starting from 0. 

The range() function accepts only integers.

range() generates a series of integer numbers. 

ITERATION / WHILE

WHILE loops are powerful because they can be used even when you don’t know how many iterations will be needed.

'While loops' repeat code whilst a condition holds true. 

The while keyword is followed by the condition under which the code is repeated

As with 'for loops', the initial 'while loop' statement must be followed by a colon : symbol

password = "SecretWord"
guess = input()
while guess != password:  
  guess = input() 
print("Access Granted")

ITERATION / WHILE / COUNTERS

Loops usually include counters. A counter is a variable that keeps track of the number of iterations. 

while seats > 0:
  print("Sell ticket")
  seats = seats - 1

In the example above, the counter is the variable "seats".

'Counter' variables are updated inside the loop, so they change with every iteration. 
An initial value is set outside the loop, as the starting point.

With while loops you can run into what is known as an infinite loop. 
This is when the condition holds true forever, and the code never stops repeating.

#Creates an infinite loop.
while seats > 0:
  print("Sell ticket")
  #seats = seats - 1

Exercise:

#Create a timer program that will take the number of seconds as input, and countdown to 0.

# take the number as input
number = int(input())

#use a while loop for the countdown
while number >= 0 :
    print(number)
    number = number - 1

Exercise:

Imagine you are a scientist looking at a new type of cell under the microscope. This type of cell divides itself into 2 daughter cells every 24 hours, meaning that the cell population duplicates every day.

Complete the code to take the initial cell population and the number of days you are observing the cells to calculate the cell population at the end of each day in the following format

# take the initial cell population as input
cells = int(input())

# take the number of days as input
days = int(input())

# initialize the day counter
counter = 1

#complete the while loop
while counter <= days:
  cells = cells * 2
  # Daily message
  print("Day " + str(counter) + ": " +str(cells))
  counter = counter + 1

#Ask user to input password guess until they get it right, then print "Access granted"
password = "SecretWord"
guess = input()
while guess != password:  
  guess = input() 
print("Access Granted")

ITERATION / BREAK

In Python, the break statement provides you with the opportunity to exit out of a loop when an external condition is 
triggered. 

You’ll put the break statement within the block of code under your loop statement, usually after a 
conditional 'if' statement.

The break statement causes a program to break out of a loop.

Examples:

number = 0

for number in range(10):
    if number == 5:
        break    # break here, will print numbers 0 to 4

    print(number)

print('Out of loop')

--

contacts = [
    ('James', 42),
    ('Amy', 24),
    ('John', 31),
    ('Amanda', 63),
    ('Bob', 18)
]

name = input()

for x in contacts:
    if name in x:
        age = str(x[1])
        break #Stops the loop once it finds name in x
    else:
        age = "no name"

if age != "no name":
    print(name, "is", age)
else:
    print("Not Found")

SELECTION / CONDITIONAL STATEMENTS / IF ELSE ELIF

Selection is like a fork in the road. It allows your programs to decide which path to take. 

Conditional statements, or if-else statements, allow programs to perform different actions based on the conditions.

The if conditional statements starts with the keyword 'if' followed by the condition and a colon : symbol

The else conditional statement starts with the keyword 'else' followed by a colon : symbol

The code indented below the else line is executed when the condition is met.

#Give discount if they're 18 or over
#sets the value of age
age = int(input())
if age >= 18:
  # executed only if customer is over-age
  print("Regular price") 
else:
  #executed only if age is less than 18
  print("Discount")
print("Proceed to payment")

#Applies a discount if the client is under 18 or a student.
if age < 18 or is_student:
  print("Discount")
else: 
  print("Regular price")

There will be situations where you don’t need the else statement. 

if age < 18:
  print("Apply Discount")
print("Proceed to payment")

When the else statement is not needed, you can simplify and have the code for the selection block in 1 line.

age = 16
if age < 18: print("Apply Discount")
print("Proceed to Payment")

You can use the elif statement (short for "else if") to check for more conditions if the first condition is not met.

As with any other conditional statement, elif requires the colon : symbol and for the code that gets executed under it to be indented.

if age < 18: 
  print("Junior discount")
elif age >= 75: 
  print("Senior discount")
else:
  print("No discount")

The if statement always goes first. Else is not always needed, but if it it is, it always goes last.

You can nest if-else statements within each other.

if age < 18:
  if is_student:
    print("20% discount")
  else:
    print("10% discount")
else:
    print("Regular price")

ITERATION / CONTINUE

The aka CONTINUE STATEMENT gives you the option to skip over the part of a loop where an external condition is triggered, 
but to go on to complete the rest of the loop. That is, the current iteration of the loop will be disrupted, but 
the program will return to the top of the loop.

The continue statement will be within the block of code under the loop statement, usually after a 
conditional 'if' statement.

You can use the continue statement to avoid deeply nested conditional code, or to optimize a loop by eliminating frequently 
occurring cases that you would like to reject.

Example:

number = 0

for number in range(10):
    if number == 5:
        continue    # continue here. They will skip number five then keep outputting numbers

    print(number)

print('Out of loop')

ITERATION / PASS

When an external condition is triggered, the aka PASS STATEMENT allows you to handle the condition without the loop 
being impacted in any way; all of the code will continue to be read unless a break or other statement occurs.

As with the other statements, the pass statement will be within the block of code under the loop statement, 
typically after a conditional if statement.

number = 0

for number in range(10):
    if number == 5:
        pass    # do nothing

    print(number)

print('Out of loop')

--

if condition:
    pass  # do nothing
else:
    # code to execute if the condition is not true
--
Pass allows you to have a syntactically correct block with no action and it doesn't affect the flow of the program. 

LISTS

Lists allow you to store a collection of multiple values in a single variable.

Add square brackets [ ] around the values to create a list and separate each value of the list with a comma.

Lists can store any data type.

shopping_list = ["eggs", "soy milk", "onions"]

prices = [0.5, 0.95, 9.95]

Lists can contain values of different data types.

movie_info = ["Inception", 2010]

You can place list items on separate lines to make the code easier to read.

bands = [
"Panic at the Disco",
"Fall Out Boy",
"My Chemical Romance"]


# Displays ['laptop', 'smartphone', 'headphones', 'backpack']
shopping_cart = [
"laptop", 
"smartphone", 
"headphones", 
"backpack"
]
print(shopping_cart)

Indentation is not necessary for lists but does make your code easier to read.

LISTS / INDEXING

Lists are ordered collections of items. You can access an item in a list using its position or index number. 
This is known as CALLING a part of the list.
Remember: Python starts counting at zero.

bands = [
 "Panic at the Disco",
 "Fall Out Boy",
 "My Chemical Romance"
]

#Refers to "Panic at the Disco"
bands[0]
#Displays "Fall Out Boy"
print(bands[1])
#Declares variable "emo_king" with value "My Chemical Romance"
emo_king = bands[2]

--

Printing items in a list using indexing:

last_calls = ["Mom", "Dave", "Lawyer"]
print(last_calls[0])
print(last_calls[1])

--

Concatinating with lists:

#Display sunrise
words = ["rise", "sun", "glasses"]
print(words[1] + words[0])

--

Declaring a variable where the value is an item from a list:

animals = ["Dog", "Cat", "Bird"]
my_pet = animals[0] 

--

Lists are mutable. This means you can change their values even after they've been created.

This will replace the value of an item, rather than add an item to the list.

bands = [
 "Panic at the Disco",
 "Fall Out Boy",
 "My Chemical Romance"
]
#Change index 1 value from "Fall Out Boy" to "Green Day"
bands[1] = "Green Day"

--

How to select an item from a list using a user input:

#installed games
games = [
  'Soccer', 
  'Tic Tac Toe', 
  'Snake',
  'Puzzle', 
  'Rally']
#taking player's choice as a number input
choice = int(input())
#output the corresponding game
print(games[choice])

--

Lists can be nested inside each other.

Color = [ ["Red", "Blue", "Yellow"], ["Green", "Purple", "Orange"] ]

--

You can create a list with values that have been stored in variables.

name = "Sarah"
age = 34
country = "Germany"
info = [name, age, country]

products = ["juice", "chocolate", "water"]
user_choice = int(input())
print(products[user_choice])

--

Indexing a list with just one number produces a string

cart = ['lamp', 'candles', 'chair', 'carpet']
example = cart[0]
#Displays lamp
print(example)
#Displays <class 'str'>
print(type(example))

--

Indexing also works with strings. You can use indexing to access individual characters in a string.
The characters in a string can include spaces and punctuation marks. 

#Display "D"
animal = "Dog"
print(animal[0])

Indexing a list to take a single item produces a string. If you want to produce a string, you need to use slicing.

beverage = ["Coffee", "Tea"]
print(beverage[1]) #Displays "Tea"
print(beverage[1:2]) #Displays ["Tea"]

Strings are immutable, which means that you can’t change the characters in a string. 
If you try to change a string you’ll get an error.

#Error
word = "car"
word[2] = "t"

Exercise:

#the list of breakfasts
breakfasts = [
  'Donuts', 
  'Waffles', 
  'Yogurt', 
  'Burrito', 
  'Toast']
#index of the item to be replaced
item = int(input())
#replace that item with "Pancakes"
breakfasts[item] = "Pancakes"
#display the updated list
print(breakfasts)

LISTS / SLICING

In this lesson you’ll learn to extract, modify and replace a specific range of elements from sequences with a new technique: slicing.

Slicing allows you to extract a portion of a list. Starting and stopping indexes are separated by a colon : 

The starting index is inclusive. The stopping index is exclusive.
i.e. The last number is excluded, the first is included, and anything in between the two is included.

animals = ["Dog", "Cat", "Bird", "Fish"]
#extracts Cat and Bird
animals[1:3]

--

animals = ["Dog", "Cat", "Bird", "Fish"]
#Displays ["Cat", "Bird", "Fish"]
print(animals[1:4])

Slicing also works with strings.

You can use indexing and slicing on lists and strings, because they are ordered sequences.

vehicle = "airplane"
#prints air
print(vehicle[0:3])

Slicing a list produces another list.

colors = ['red', 'green', 'blue', 'yellow']
#prints ['blue']
print(colors[2:3])

Slicing a string produces another string.

fruit = "orange"
print(fruit[0:2]) #Displays or
print(type(fruit[0:2])) #Displays <class 'str'>

--

When slicing, you can omit the starting index. This means that you'll be slicing from the very first element.

cart = ['lamp', 'candles', 'chair', 'carpet']
print(cart[:3])

This also works with strings:

vehicle = "motorbike"
print(vehicle[:5]) #Displays motor

--

When slicing, you can omit the stopping index. This means that you'll be slicing until the very last element.

cart = ['lamp', 'candles', 'chair', 'carpet']
print(cart[1:])

This also works with strings.

--

You can also omit all indexes to just take the whole list/string.

vehicle = 'motorbike'
print(vehicle[:]) #Display motorbike

--

You can also use slicing to change a list.

letters = ["A", "B", "C", "D"]
letters[-2:] = ["E", "F"]
print(letters) #Displays ["A", "B", "E", "F"]

This doesn't work with strings because they're immutable.

LISTS / NEGATIVE INDEXING

Python supports "indexing from the end", called negative indexing. This means the last value of a sequence has an index of -1.

Cat Dog Fox Cow
-4  -3  -2  -1

animals =["cat", "dog", "bird", "cow"]
print(animals[-1]) # Last element
print(animals[-2]) # Second last element
print(animals[-3:]) # Last 3 elements
print(animals[-3:-1]) 

In indexing from the end, you start with the smallest number (Remember they're negative numbers!!! -3 < -2)

You can combine positive with negative indexing when slicing.

c = ['A', 'B', 'C', 'D']
print(c[1:-1]) #Displays ['B', 'C']

--

c = ['A', 'B', 'C', 'D']
c[:2] = ['E', 'F']
#Display ['E', 'F', 'C', 'D']
print(c)

LIST / IN vs NOT IN

To determine whether a value is in a list, you can use in and not in.

Example:

nums = [ 1, 2, 3]
print(1 in nums) #Display True
print("three" in nums) #Display False
print(4 not in nums) #Display True

LIST / UNPACKIN LISTS

List unpacking allows you to assign each item in a collection to a variable.

numbers = [1, 2, 3]
a, b, c = numbers # Declares three variables, each with a value equal to one of the items of the list
print(a) # Displays 1
print(b) # Displays 2
print(c) # Displays 3

LIST COMPREHENSION

List comprehensions are a way to create lists based on a specific rule or pattern. 
It's like using a formula in math to create a set of numbers. 
This concept is inspired by a notation used in math called set-builder notation.

# a list comprehension
squares = [i**2 for i in range(5)] # Makes a list of squares of number from 0 to 4

print(squares) # Displays [0, 1, 4, 9, 16]

--

nums = [i*2 for i in range(10)] # A list of even numbers between 0 and 18

--

A list comprehension can also contain an if statement to enforce a condition on values in the list.

# A list of cubes of number where those numbers are even
# % the % symbol is used for finding the remainder when one number is divided by another
# Since the condition is i**3 % 2 == 0, the list will only include numbers ^3 that are even (divisible between 2 without a remainder)
cubed_evens=[i**3 for i in range(10) if i**3 % 2 == 0] 

print(cubed_evens) # Displays [0, 8, 64, 216, 512]

--

# Create a list of multiples of 3 from 0 to 20.

multiples3 = [i for i in range(21) if i % 3 == 0]

--


word = str(input())

# Removes vowels from word
not_vowels = [i for i in word if i != "a" and i != "e" and i != "i" and i != "o" and i != "u"]

print(not_vowels)


FUNCTIONS

Functions are reusable blocks of code for specific tasks. 
They help keep your code as short and easy to work with as possible, saving you from repeating code.
A function performs a task. 

print(), input(), range(), and type() are functions.

A function contains the code to perform a task. To use this code, you just need to aka CALL the function.

Every function has a name. The code within a function is only executed when the function is aka CALLED.

The same function can be called multiple times.

Functions require information to be passed in order for the task to be completed. 
We pass information into functions as aka ARGUMENTS.

A function argument is a value passed when calling a function.

Arguments go inside parenthesis ().

For instance, when we add "New Message" to the print() function, we aka PASS THE ARGUMENT "New Message".

print("New Message")

In this example print() is the NAME of the function, and "New Message" the ARGUMENT.

Most functions need their arguments to work. Missing arguments can result in errors.

A function can take multiple arguments.

For example, we can pass multiple arguments to the print() function to display multiple values in one line.

print("Your seat:", 4)

That example has two arguments.

--

Multiple arguments in a function are separated with a comma.

--

print(), type () and range() are examples of aka BUILT-IN FUNCTIONS. 
Python has many built-in functions which you can re-use in your code by calling them.

Built-in functions like print() and range() are blocks of code created by others to do specific things. 
This simplifies the code a lot, as you don’t need to rewrite the code each time. All you need to do is to call them!

--

Functions can take operations as arguments. 

As an example, the print() function can accept math, logical and comparison operations.

print(50 * 3) #Math: Display 150
print(5 > 7) #comparison
print(True and False) #logical
print("motor" + "bike") #concatenation

--

Different functions accept different types of arguments. For example, the range() function accepts only integers.

--

You can use values stored in variables as arguments.

balance = 304
print("Money in account:", balance)

--

A function can be an argument for another function.

print(type("word"))
print(range(3))

--

Your code will result in errors if you pass the incorrect data type as an argument. 
Some functions require specific data types as arguments.

For example, the int() function won't be able to convert non-numeric characters (e.g. a–z) into numbers and 
it'll result in an error.



CONCATENATION vs DISPLAYING SEVERAL ARGUMENTS

Concatenation displays arguments one after another without spaces
Displaying several arguments displays them with spaces

element = "air"
vehicle = "plane"
print(element + vehicle) #Displays airplane
print(element, vehicle) #Displays air plane

STRING FUNCTIONS

Correctly handling text data is a key skill all coders need to master. 
String functions will enhance your productivity when working with text.

STRING FUNCTIONS / UPPER (),  LOWER ()

The functions upper() and lower() allow you to quickly change the case of a string to all in uppercase or lowercase, respectively.

print('SmArTpHoNe'.lower()) #Displays smartphone
print('SmArTpHoNe'.upper()) #Displays SMARTPHONE

brand = "ikea"
print(brand.upper()) #Displays IKEA

upper() and lower() functions can only be used on strings. 

Functions that only work on certain objects (strings, lists, etc.) are called using dot . notation.

Strings are immutable and functions won't change them. You'll need to store the modified string in a variable to keep it.

STRING FUNCTIONS / CAPITALIZE()

The capitalize() function will save you time when you need to convert the first character of a string to uppercase, 
while making the remaining characters lowercase.

print("happy birthday".capitalize()) #Displays Happy birthday

name = "JAMES"
print(name.capitalize()) #Displays James

--

Strings are immutable and functions won't change them. You'll need to store the modified string in a variable to keep it.


item = "smartwatch"
item2 = item.upper()

You can get around that declaring the variable again.

name = "james"
name = name.capitalize()


STRING FUNCTIONS / FIND()

The find() function checks if a character (or a pattern of characters) is present in a string. 
The function returns the index (position) of the given value. 

If the given value is present multiple times, the function will return the first occurrence (the lowest index).

print("Bee".find("e")) #Displays 1 because that's the index of the first e letter

The find() function can only be used with strings so you call it using dot notation.

find() will return an error if you don't include an argument between the parentheses. 
With nothing to look for in the string, the function can't do its job.

This won't happen with upper(), lower() and capitalize(). They don't need any more information to complete their task.

'roBot'.find() # error
'roBot'.upper() # no error

--

find() will return -1 if the value can't be found in the string.

print("robot".find("A")) #Displays -1 because there are no As in the string "robot"

--

The argument inside find() is case-sensitive.

print('roBot'.find("b")) #Displays -1 because there's no lowercase b in "roBot"
print('roBot'.find("B")) #Displays 2 because that's the index of the uppercase B in "roBot"
print('roBot'.lower().find("b")) #Displays 2 because lower() put everything in lowercase
print('roBot'.find("B" or "b")) #Displays 2 because you can use the "or" logical operation inside a find()

STRING FUNCTION / LEN()

len() stands for length and, when used on strings, it aka RETURNS the number of characters in the string.

The len() function accepts as an argument any sequence, including strings. 
It doesn't accept integers, floats or booleans, however.

movie = "Avatar"
print(len(movie)) #Display 6

len() can also be used on lists. We'll learn about that later.

LIST FUNCTIONS

In this lesson you'll learn to use built-in list functions.

LIST FUNCTIONS / LEN()

len() is one of the most useful built-in functions.

len() stands for length and, when used on lists, it returns the number of items in the list.

movies = ["Avatar", "Titanic", "Avengers"]
print(len(movies)) #Display 3

The len() function is not only for lists. It accepts as an argument any sequence, including strings.

movie = "Avatar"
print(len(movie)) #Display 6

len() is a very useful function that accepts a wide range of arguments. 
It’s not specific to a any particular data type or object, so you don’t use dot notation to call it.

It cannot be used with integers, floats or booleans, however.

LIST FUNCTIONS / APPEND()

The append() function adds a new item to the end of a list. 
append() is called using dot notation because it’s specific to lists.

songs = ["Yesterday", "Hello", "Believer"]
songs.append("Imagine")
print(songs) #Display ['Yesterday', 'Hello', 'Believer', 'Imagine']

The append() function is for lists. If you try to use append() on a string you’ll get an error. 
This happens because strings are immutable.

LIST FUNCTIONS / INSERT()

The insert() function allows you to add an element to a list, at a specific position.

items = ["book", "pen", "pencil"]
items.insert(2, "marker")
print(items) #Display ['book', 'pen', 'marker', 'pencil']
print(items[2]) #Display marker

insert() takes 2 arguments. The first is the index (where to insert) and the second is the item (what to insert).

LIST FUNCTIONS / POP()

The pop() function removes an element from a list.
The position indicated by the index is the only argument that the pop() function accepts.

items = ["book", "pen", "pencil"]
items.pop(1) #Removes "pen" from the list
print(items)
print(items[1])

CUSTOM FUNCTIONS / def

Built-in functions can save you a lot of work, but you’ll also need to create your 
own aka CUSTOM FUNCTIONS to solve specific tasks.

A function is a reusable block of code.

To use your own functions, you need to aka DEFINE them first.  

Once a function has been defined, you can aka CALL it as many times as you need.

The greet() function below contains code to display a nice message when called

#function definition
def greet():
  print("Hello from a function")
  print("Have a great day")
#function call
greet()

Use def followed by a name to define a new function
When a function is defined, you need to make sure parentheses () are added after the name. 
A colon : must be added at the end of the definition line.

---

The BODY of a function contains the reusable code that is executed when the function is called. 
The code for the body of a function must be indented.

---

A function might require arguments to complete its tasks. 
You can define functions that take any number of arguments (including zero).  
Arguments are put inside the parentheses () following the function name.

#function definition
def personal_greet(name): 
  print("Hello", name)
  print("Have a great day")

#function calls
personal_greet("Sarah") 
personal_greet("Henry")
personal_greet(input())

--

#Define the function
def double(number):
    print(number*2)

#Call the function
double(6) #Displays 12

--

Functions must be defined before they can be called. 

---

Exercise:

weight = 73
height = 1.5

#Defines function
def bmi_calculator(weight, height):
    bmi = weight / height **2
    print(bmi)

#Calls function
bmi_calculator(weight, height)

--

When calling a function, you need to use the same number of arguments that have been defined, in the same order.

--

When you have a variable inside a function, it's a aka LOCAL VARIABLE.

Local variables are not accessible outside the function unless you use RETURN to turn them 
into the value that the function returns.

RETURN

A function can declare different variables, do different operations, and in general, do a lot of stuff.

You have to decide which of those things will be the value that the function will return.

A aka RETURN STATEMENT in a function is used to specify the value that the function should produce when it is called.

The return statement does not set the value of the function itself; rather, it determines the output of the function. 

Once a return statement is encountered, the function exits, and the specified value is returned to the caller. 

The execution of the code inside a function ends when a value is returned. 
Any additional lines of code after the return line will be ignored.

This returned value can be directly used, assigned to a variable, or involved in further operations in the calling code.

This code will print 32.444:

weight = 73
height = 1.5

def bmi_calculator(weight, height):
    bmi = weight / height ** 2
    return bmi
    
print(bmi_calculator(weight, height))

This code will print None:

weight = 73
height = 1.5

def bmi_calculator(weight, height):
    bmi = weight / height ** 2
    
result_bmi_calculator = bmi_calculator(weight, height)

print(result_bmi_calculator)

This is because without the return statement, the function returns no value.

Another example: this will print the final grade because there's a return statement.

exam_1 = 6.5
exam_2 = 9

def calculate_grade(exam_1, exam_2):
    final_grade = (exam_1 +exam_2)/2
    return final_grade
    
print(calculate_grade(exam_1, exam_2))

Another example where the mathematical operation is done directly on the return statement:

#taking the weight as input
weight = int(input())

#complete the function
def shipping_cost(weight):
     return weight * 5

#function call
print(shipping_cost(weight), "€")

RETURNING MULTIPLE VALUES

A function can return multiple values.

Multiple return values need to be separated by commas.

When a function returns multiple values, they can be stored in multiple variables (on 1 line).

To create multiple variables in 1 statement, separate them with commas.

height, weight = 150, 72.9

Example:

The function rect() helps a real estate agency calculate the area and perimeter of a rectangular parcel of land. 
It takes the two dimensions of the parcel as arguments

def rect(length, width):
  area = length * width
  perimeter = 2 * length + 2 * width
  return area, perimeter #2 values

#x is the first variable so it will be the first value returned (area)
#y is the second variable so it will be the second value returned (perimeter)
x, y = rect(50, 100) #2 variables
#prints are and perimeter
print(x, y)

--

It's up to you as a coder to define what operations happen inside your function. 
This then controls which data types can be handled and returned.

Pay attention to data types when creating a function.

--

The same function can handle more than one type of data.

#Returns whether buying a parcel of land is profitable as a boolean
def profitable(d1, d2):
  area = d1 * d2
  invest = area > 700
  return invest

buy = profitable(90, 120)
print(buy)

NONLOCAL

The nonlocal keyword is used to work with variables inside nested functions, where the variable should 
not belong to the inner function. Use the keyword nonlocal to declare that the variable is not local.

GLOBAL

In Python, the global keyword allows us to modify the variable outside of the current scope.

It is used to create a global variable and make changes to the variable in a local context.

FUNCTION ARGUMENTS / DEFAULT VALUES

Python allows function arguments to have default values. 
If the function is called without the argument, the argument gets its default value.

Add the default value with the equal = sign to make the argument optional.

The default value is used only if no other value has been passed as an argument when the function is called.

def greet(name="Guest"):
  print("Welcome", name)

greet() # Welcome Guest
greet("John") # Welcome John

-

def call_phone(phone = 555):
  print("Call", phone)

call_phone()
call_phone(1234)

DICTIONARIES

Python provides a number of built-in collection types, to store multiple values.

Lists are one of these collection types, and they allow you to store indexed values.

Dictionaries are another collection type and allow you to map arbitrary keys to values.
Dictionaries can be indexed in the same way as lists, using square brackets containing aka KEYS and their VALUES.

Each element in a dictionary is represented by a key:value pair.

Examples:

ages = {
   "Dave": 24,
   "Mary": 42,
   "John": 58
}

print(ages["Dave"]) #Displays 24
print(ages["Mary"]) #Displays 42

--
cars = {
  "BMV" : "Blue", 
  "Volvo" : "Red" 
  }

--

Dictionaries can be nested inside each other.

--
Only immutable objects can be used as keys to dictionaries. Immutable objects are those that can't be changed.
So far, the only mutable objects you've come across are lists and dictionaries.

Therefore lists and dictionaries can't be used as keys.

bad_dict = { [1, 2, 3]: "one two three" } #Error

Strings, booleans, integers and floats can be used as keys.

--

Dictionaries can be nested inside each other:

Color = { primary_colors : {"Red", "Blue", "Yellow"}, secondary_colors : {"Green", "Purple", "Orange"} }

DICTIONARIES / FUNCTIONS

DICTIONARIES / FUNCTIONS / IN vs NOT IN

To determine whether a key is in a dictionary, you can use in and not in, just as you can for a list.

Example:

nums = {
    1: "one",
    2: "two",
    3: "three",
}
print(1 in nums) #Display True
print("three" in nums) #Display False
print(4 not in nums) #Display True

DICTIONARIES / FUNCTIONS / GET

A useful dictionary function is get. It does the same thing as indexing, but if 
the key is not found in the dictionary it returns another specified value instead.

The syntax of get is: dictionary_name.get(key) and dictionary_name.get(key, "value to otherwise return")

This function only works with dictionaries so it uses dot . notation.

pairs = {
   1: "apple",
   "orange": [2, 3, 4], 
   True: False, 
   12: "True",
}

print(pairs.get("orange")) #Displays [2, 3, 4]
print(pairs.get(12345, "not found")) #Displays "not found"

--
#Script to check a student's grades
#Dictionary with every student's grades
grades = {
    "James" : 8,
    "Mark" : 4,
    "Emily" : 7,
    "Sarah" : 9,
}

#Gets the name of the student
name = str(input("What's your name? "))

#Prints student's grade or "Student not found" if name is not in dictionary
print(grades.get(name, "Student not found"))

--

fib = {1: 1, 2: 1, 3: 2, 4: 3}
print(fib.get(4, 0) + fib.get(7, 5)) #Displays 8 because the valor of 4 is 3 and there's no 7 key so you add 5

--

car = {
    'brand':'BMW',
    'year': 2018,
    'color': 'red',
    'mileage': 15000
}

question = input("What information would you like to recover?")

print(car.get(question, "Not found"))

--

TUPLES

Tuples are very similar to lists, except that they are immutable (they cannot be changed).
Also, they are created using parentheses, rather than square brackets.

words = ("spam", "eggs", "sausages")

--

You can access the values in the tuple with their index, just as you did with lists:

print(words[0]) #Display spam

--

Since Tuples are immutable, they can be used as keys in Dictionaries

# Creating a dictionary with a tuple as a key
my_dict = {('John', 25): 'Engineer', ('Alice', 30): 'Doctor', ('Bob', 28): 'Teacher'}

# Accessing values using tuple keys
print(my_dict[('John', 25)])  # Output: Engineer
print(my_dict[('Alice', 30)])  # Output: Doctor

--

Trying to reassign a value in a tuple causes an error because they're immutable.

--

Like lists and dictionaries, tuples can be nested within each other.

nested_tuple = ((1, 2, 3), ('a', 'b', 'c'), ('apple', 'banana', 'cherry'))

--

Tuples can also be created without the parentheses by just separating the values with commas.

my_tuple = "one", "two", "three"

INDEXING IN NESTED TUPLES

tuple = (1, (1, 2, 3))
print(tuple[1]) #Displays (1, 2, 3)

INDEXING A VALUE IN NESTED LISTS / TUPLES / DICTIONARIES

contacts = [
    ('James', 42),
    ('John', 18)
]

# Reference the second value of the first tuple
second_value_of_first_tuple = contacts[0][1]

print(second_value_of_first_tuple) #Displays 42

The first index (contacts[0]) selects the first tuple, and the second index ([1]) selects the second element within that tuple.

TUPLE / UNPACKING

Tuple unpacking allows you to assign each item in a collection to a variable.

numbers = (1, 2, 3)
a, b, c = numbers # Declares three variables, each with a value equal to one of the items of the tuple
print(a) # Displays 1
print(b) # Displays 2
print(c) # Displays 3

You can also use tuple unpacking to swap variables.

a, b = b, a 

is equivalent to:

temp = a
a = b
b = temp

Example:

x, y = [1, 2]
x, y = y, x

print(y) # Displays 1

A variable that is prefaced with an asterisk (*) takes all values from the collection that are left over from the other variables.

a, b, *c, d = [1, 2, 3, 4, 5, 6, 7, 8, 9]
print(a) # Displays 1
print(b) # Displays 2
print(c) # Displays [3, 4, 5, 6, 7, 8]
print(d) # Displays 9

SETS

Sets are similar to lists or dictionaries.
They are created using curly braces, and are unordered, which means that they CAN'T BE INDEXED.

(REMINDER: the syntax for a dictionary is:

user = {"name": "James", "age" : 32, "pet" : "dog"}

the syntex for a set is:

user = {"James", 32, "dog}

---

Due to the way they're stored, it's faster to check whether an item is part of a set using the IN operator, rather than part of a list.

num_set = {1, 2, 3, 4, 5}

print(3 in num_set) # Displays True

--

letters = {"a", "b", "c", "d"}
if "e" not in letters:
 print("Found") 
else:
 print("Not Found")

# Displays Not Found

--

SETS / AD() AND REMOVE()

You can use the add() function to add new items to the set, and remove() to delete a specific element.

These functions can only be used with sets, so they use dot notation.

nums = {1, 2, 1, 3, 1, 4, 5, 6}
nums.add(-7)
nums.remove(3)
print(nums) # Displays {1, 2, 4, 5, 6, -7}

SETS / LEN()

The len() function can be used to return the number of elements of a set.

nums = {1, 2, 3}
print(len(nums)) # Displays 3

SETS / MATHEMATICAL OPERATIONS

Sets can be combined using mathematical operations.
The union operator | combines two sets to form a new one containing items in either.
The intersection operator & gets items only in both.
The difference operator - gets items in the first set but not in the second.
The symmetric difference operator ^ gets items in either set, but not both.

first = {1, 2, 3, 4,}
second = {4, 5, 6}

print(first | second) # Displays {1, 2, 3, 4, 5, 6}
print(first & second) # Displays {4}
print(first - second) # Displays {1, 2, 3}
print(second - first) # Displays {5, 6}
print(first ^ second) # Displays {1, 2, 3, 5, 6}

LIST, DICTIONARIES, TUPLES AND SETS

When to use a dictionary:
- When you need a logical association between a key:value pair.
- When you need fast lookup for your data, based on a custom key.
- When your data is being constantly modified. Remember, dictionaries are mutable.

When to use the other types:
- Use lists if you have a collection of data that does not need random access. 
  - Can be indexed
  - Try to choose lists when you need a simple, iterable collection that is modified frequently.
  - Are mutable
- Use a set if you need uniqueness for the elements.
  - Mutable 
  - Cannot be indexed
  - Does not allow duplicate values
- Use tuples when your data cannot/should not change.
  - Immutable
  - Can be indexed
  - Can be sliced

Many times, a tuple is used in combination with a dictionary, for example, 
a tuple might represent a key, because it's immutable.

LIST, STRINGS AND TUPLES / COUNT ()

Can be used with lists, strings and tuples.

Use dot notation and is given the element to be searched for as its first parameter. 

This can be a single number or character, as well as entire Python strings.

fruits = ['apple', 'banana', 'cherry']

x = fruits.count("cherry")

--

fruits = ['apple', 'banana', 'cherry']

print(fruits.count("a")) # Displays 0

--

food = "potatoes"

print(food.count("t")) # Displays 2

SPLIT()

The split() method splits a string into a list.

You can specify the separator. The default separator is any whitespace.

The syntax is:

string.split(separator, maxsplit)

separator:	Optional. Specifies the separator to use when splitting the string. By default any whitespace is a separator
maxsplit:	Optional. Specifies how many splits to do. Default value is -1, which is "all occurrences"

sentence = "En un lugar de la Mancha"
print(sentence.split(" ", 2)) # Displays ['En', 'un', 'lugar de la Mancha']

sentence = "En un lugar de la Mancha"
print(sentence.split(" ", 2)) # Displays ['En', 'un', 'lugar', 'de', 'la', 'Mancha']


\N \T AND \

print("\nThis will print on the next line")
print("\tThis is tabbed in")
print("\"This line will appear in quotes\"")
