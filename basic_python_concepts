The code in computer programs is made of statements. Statements are the instructions for the computer to follow. Real programs can contain thousands of statements.

DATA TYPES

- Strings: text
- Integers: whole numbers without a decimal point. Negative, positive or zero.
- Float: numbers with decimal places, they can be positive or negative. 
 - The division of two integers always produces a float. 
 - Math operations between integers and floats produce a float.
- Boolean: two possible values: True or False

a = 4
b = 2
c = 4/2
print(c) #displays the result
print(type(c)) #displays data type which will be float

STRINGS

In Python, both single ' and double " quotes can be used to define strings. 
It doesn’t make a difference whether you choose double or single quotation marks, but they do need to match.

Anything in quotation marks will be treated as a string, even numbers.

movie = "Gladiator"
book = "1984"

CONCATENATION

When you use the + addition operator with string values the two strings are joined together. 

This is known as concatenation.

You can't concatenate a string with a integer or float.

#Displays IronMan
print("Iron" + "Man")

#Displays basketball
a = "basket"
b = "ball"
print(a+b)

NUMERICAL DATA

Numerical data shouldn't be in quotation marks. The line of code below declares a numerical variable

price = 10

You can perform math operations with numbers. Each print() instruction will add a value to the screen in a new line.

print(7 + 3)

The computer reads and executes instructions line by line, from top to bottom. 
The execution of the program will be interrupted at the first error encountered.


PRINT

The print() instruction is the easiest way to send a message to the screen or other display device.

print("Hello world.")

Numbers don't require quotation marks.

print(42)

VARIABLE

Computer programs use variables to store important information, like items in a shopping cart, prices and discounts.

The line of code below tells the computer to store information in a variable called item.

This is called "declaring a variable".

Spaces are not allowed in variable names in Python. Asterisks (*) aren't either.

item = "bike"
name_of_variable = "value"

A variable name can contain numbers but cannot start with a number.

Variables have a name and a value. They are connected with the equal sign =.

A variable’s name is used to identify where that information is stored. You can access the value that a variable is storing by calling its name.

budget = 200
print(budget)

budget = 20
print(budget + 10)

price = 5
amount = 3
total = price * amount

You can update the value stored in a variable. The variable will forget the previously stored value.
Updating the value of a variable is called reassigning a variable.

price = 99
price = 100
print(price)

COMMENTS

Professional developers use comments to add descriptions and explanations to their programs.

You can add comments to your Python code with the hash symbol #

#Displaying a message
print("Insufficient funds")

You can use comments to temporarily disable a statement. This way the computer will skip the instruction.

CASE-SENSITIVE

Python is a case-sensitive language, meaning "A" and "a" are treated as different.

credit = 300
Credit = 280
CREDIT = 320

SNAKE CASE

Snake case is a popular way to create variable names in a consistent way. 
Snake case uses underscores _ to separate words in a variable name.

name_username = "John Doe"

Snake case is the best practice for naming variables in Python.

INPUT

An input is any information that goes into a computer.

The press of a key and the click of a button are examples of inputs.

The input() instruction is the easiest way to allow a user to insert a value into your program.

#Display a window that asks you to write an input
#message's value will be whatever you write in that window
message = input()
print(message)

#Ask user for their age
age = input()

The input() instruction always turns the user input into a string, no matter what the user enters.

birth_year=input() #takes an input
print(type(birth_year)) #displays the data type which will be str

OUTPUT

An output is a way for the computer to communicate with the outside world. 
A message displayed on the screen and the sound from a speaker are examples of outputs.

The print() instruction, which you already know, is the easiest way to get your computer program to generate an output.

TYPE

Data can come to you in the incorrect format. You can use the type() instruction to check the data type stored in a variable.

city = "Berlin" #stores a string
age = 42 #stores an integer
balance = 830.29 #stores a float
print(type(city)) #outputs <class 'str'>
print(type(age)) #outputs <class 'int'>
print(type(balance)) #outputs <class 'float'>

DATA CONVERSION

INT()

The int() instruction converts any type of value into an integer

x = "55" # x is a string
y = int(x) # y is an integer

You can use the int() instruction to convert the user input into an integer

# User input is converted into an integer
height = int(input()) 
print(type(height))
# The line above is an effective way to combine 2 instructions into one

FLOAT()

There are situations when you need values to be treated as floats.

The float() instruction converts values into floats.

a = 3
b = float(a)
print(b) #Will display 3.0

STR()

In a similar way, you can ensure that values are converted into strings with the str() instruction.

a = 3
b = str(a)
print(type(b)) #print type str

str() helps you concatenate two variables.

name = "Tom"
age = 33
print(name + str(age))

EXPLICIT AND IMPLICIT CONVERSION

The int(), str() and float() instructions are examples of explicit conversion, which means they are performed by an instruction given by a programmer (like you).

On the other hand, run the code to see some examples of implicit (automatic) data type conversions

# Examples of automatic data type conversion

x = 5 # integer
y = 2 # integer
z = x/y # float (implicit conversion)
print(z)

a = 3 # integer
b = 1.5 # float
c = a + b # float
print(c)

EXERCISE

# Asks the user to enter the savings
savings = input()

# Convert the user input into a float value and update the variable
savings = float(savings)

# Savings grow after 1 year at a 5% annual interest rate
balance = savings * 1.05 

# Convert the balance into a string and update the variable
balance = str(balance)

# Concatenate the 2 strings to produce a message
message = "Amount in 1 year: " +  balance

# Display the message
print(message)

--

# Convert the values into numbers
wins = int(input())
ties = int(input())

# 1 win = 3 points
# 1 tie = 1 point 
# Calculate the score
score = wins * 3 + ties

# Concatenate the 2 strings to produce a message
message = "Score: " + str(score)

# Display the message
print(message)

COMPARISON OPERATIONS / BOOLEAN DATA TYPES

A comparison operation always results in either one of these two outcomes: True or False

#Compares 5 and 9 and returns true because 5 is smaller than 9
print(5 < 9)

#Tells you whether 40 is bigger or equal to 40
print(40 >= 40)

#Tells you whether a is equal to b
a = 4
b = 5
print(a == b)

#Tells you if variables a and b are not equal
a = 4
b = 5
print(a != b)

You can store booleans values in variables like you do with other data types.

passed_exam = True

You can store the result of a comparison operation as a variable.

peak_rate = heart_rate > 160

#Will print True 
heart_rate = 165
peak_rate = heart_rate > 160
print(peak_rate)

LOGICAL OPERATIONS 

A logical operation takes several boolean inputs and produces 1 boolean output.

- The "and" operation results in a True value only when all the inputs are True at the same time. 
- The "or" logical operation results in a True value if at least one of the inputs is True.

Logical operations need to be inserted in print() instructions for the result to be outputted.

print(True and False)
print(False and True)
print(True or False)
print(False or True)

Python is a case-sensitive language. 

- Both "True" and "False" start with an uppercase letter.
- Both "and" and "or" operators are lowercase in Python. 

You can put parentheses around the operations that should be done first. It makes the code easier to read.

#variable value is True because 3 > 2
a = (3 > 2) or False

CONTROL FLOW

In this lesson, you'll learn to control the flow of instructions a computer follows, using 3 techniques: sequencing, iteration and selection.

- SEQUENCING: computer runs your code in order, from top to bottom.
- ITERATION: is about executing an instruction repeatedly. Iteration is commonly represented as a loop.
- SELECTION: specifies when to follow each path.

An algorithm is a set of step-by-step instructions to complete a task, placed in a certain order.

Flowcharts help to visualize algorithms.

Another way to represent an algorithm is with pseudocode. 
Pseudocode is a simplified language that is a bit closer to a programming language.

ITERATION / FOR

Iteration is used to automate tasks that need to be done over and over again. 

Iteration makes your programs simpler, faster and reduces errors.

The for loop begins with the keyword "for".

ITERATION / RANGE()

"range()" generates a sequence of numbers, starting from 0. range() generates a series of integer numbers. 

The initial loop statement must be followed by a colon : symbol. This signals the start of the iteration block.

You need an internal variable for the loop, which can be "i", "potato", or anything else.

#Define the number of iterations
for i in range(3):
  #Statement that gets repeated
  print("Hello")

# Loop using i as internal variable
for i in range(3):
  print(i)
print("--")   #This is just a separator
#Loop using "something" as internal variable
for something in range(3):
  print(something)

#Displays 3 booleans
for i in range(3):
  print(i < 1)

The code that gets repeated in the for loop must be indented. Indentation is the spaces at the beginning of lines.

Python doesn't mind whether you use 2 spaces or 4 spaces (or any other number of spaces) or tabs as long as you use the same indentation with every loop.

ITERATION / WHILE

While loops are powerful because they can be used even when you don’t know how many iterations will be needed.

While loops repeat code whilst a condition holds true. 

The while keyword is followed by the condition under which the code is repeated

As with for loops, the initial while loop statement must be followed by a colon : symbol

while seats > 0:
  print("Sell ticket")
  seats = seats - 1

Loops usually include counters. A counter is a variable that keeps track of the number of iterations. 

In the example above, the counter is the variable "seats".

Counter variables are updated inside the loop, so they change with every iteration. 
An initial value is set outside the loop, as the starting point.

With while loops you can run into what is known as an infinite loop. 
This is when the condition holds true forever, and the code never stops repeating.

#Creates an infinite loop.
while seats > 0:
  print("Sell ticket")
  #seats = seats - 1

#Create a timer program that will take 
#the number of seconds as input, and countdown to 0.
# take the number as input
number = int(input())
#use a while loop for the countdown
while number >= 0 :
    print(number)
    number = number - 1

Exercise:

Imagine you are a scientist looking at a new type of cell under the microscope. This type of cell divides itself into 2 daughter cells every 24 hours, meaning that the cell population duplicates every day.

Complete the code to take the initial cell population and the number of days you are observing the cells to calculate the cell population at the end of each day in the following format

# take the initial cell population as input
cells = int(input())

# take the number of days as input
days = int(input())

# initialize the day counter
counter = 1

#complete the while loop
while counter <= days:
  cells = cells * 2
  # Daily message
  print("Day " + str(counter) + ": " +str(cells))
  counter = counter + 1

#Ask user to input password guess until they get it right, then print "Access granted"
password = "SecretWord"
guess = input()
while guess != password:  
  guess = input() 
print("Access Granted")

SELECTION / CONDITIONAL STATEMENTS / IF ELSE ELIF

Selection is like a fork in the road. It allows your programs to decide which path to take. 

Conditional statements, or if-else statements, allow programs to perform different actions based on the conditions.

The if conditional statements starts with the keyword if followed by the condition and a colon : symbol

The else conditional statement starts with the keyword else followed by a colon : symbol

The code  indented below the else line is executed when the condition is not met

#Give discount if they're 18 or over
#sets the value of age
age = int(input())
if age >= 18:
  # executed only if customer is over-age
  print("Regular price") 
else:
  #executed only if age is less than 18
  print("Discount")
print("Proceed to payment")

#Applies a discount if the client is under 18 or a student.
if age < 18 or is_student:
  print("Discount")
else: 
  print("Regular price")

There will be situations where you don’t need the else statement. 

if age < 18:
  print("Apply Discount")
print("Proceed to payment")

When the else statement is not needed, you can simplify and have the code for the selection block in 1 line.

age = 16
if age < 18: print("Apply Discount")
print("Proceed to Payment")

You can use the elif statement (short for "else if") to check for more conditions if the first condition is not met.

As with any other conditional statement, elif requires the colon : symbol and for the code that gets executed under it to be indented.

if age < 18: 
  print("Junior discount")
elif age >= 75: 
  print("Senior discount")
else:
  print("No discount")

The if statement always goes first. Else is not always needed, but if it it is, it always goes last.

You can nest if-else statements within each other.

if age < 18:
  if is_student:
    print("20% discount")
  else:
    print("10% discount")
else:
    print("Regular price")

LISTS

Lists allow you to store a collection of multiple values in a single variable.

Add square brackets [ ] around the values to create a list and separate each value of the list with a comma.

Lists can store any data type.

shopping_list = ["eggs", "soy milk", "onions"]

prices = [0.5, 0.95, 9.95]

Lists can contain values of different data types.

movie_info = ["Inception", 2010]

You can place list items on separate lines to make the code easier to read.

bands = [
"Panic at the Disco",
"Fall Out Boy",
"My Chemical Romance"]


# Displays ['laptop', 'smartphone', 'headphones', 'backpack']
shopping_cart = [
"laptop", 
"smartphone", 
"headphones", 
"backpack"
]
print(shopping_cart)

Indentation is not necessary for lists but does make your code easier to read.

LISTS / INDEXING

Lists are ordered collections of items. You can access an item in a list using its position or index number. 
This is known as CALLING a part of the list.
Remember: Python starts counting at zero.

bands = [
 "Panic at the Disco",
 "Fall Out Boy",
 "My Chemical Romance"
]
#Refers to "Panic at the Disco"
bands[0]
#Displays "Fall Out Boy"
print(bands[1]
#Declares variable "emo_king" with value "My Chemical Romance"
emo_king = bands[2]

last_calls = ["Mom", "Dave", "Lawyer"]
print(last_calls[0])
print(last_calls[1])

#Display sunrise
words = ["rise", "sun", "glasses"]
print(words[1] + words[0])

Lists are mutable. This means you can change their values even after they've been created.

bands = [
 "Panic at the Disco",
 "Fall Out Boy",
 "My Chemical Romance"
]
#Change index 1 value from "Fall Out Boy" to "Green Day"
bands[1] = "Green Day"

#installed games
games = [
  'Soccer', 'Tic Tac Toe', 'Snake',
  'Puzzle', 'Rally']
#taking player's choice as a number input
choice = int(input())
#output the corresponding game
print(games[choice])

You can create a list with values that have been stored in variables.

name = "Sarah"
age = 34
country = "Germany"
info = [name, age, country]

products = ["juice", "chocolate", "water"]
user_choice = int(input())
print(products[user_choice])

Indexing a list with just one number produces a string

cart = ['lamp', 'candles', 'chair', 'carpet']
example = cart[0]
#Displays lamp
print(example)
#Displays <class 'str'>
print(type(example))

Indexing also works with strings. You can use indexing to access individual characters in a string.
The characters in a string can include spaces and punctuation marks. 

#Display "D"
animal = "Dog"
print(animal[0])

Strings are immutable, which means that you can’t change the characters in a string. 
If you try to change a string you’ll get an error.

#Error
word = "car"
word[2] = "t"

#the list of breakfasts
breakfasts = [
  'Donuts', 
  'Waffles', 
  'Yogurt', 
  'Burrito', 
  'Toast']
#index of the item to be replaced
item = int(input())
#replace that item with "Pancakes"
breakfasts[item] = "Pancakes"
#display the updated list
print(breakfasts)

SLICING

In this lesson you’ll learn to extract, modify and replace a specific range of elements from sequences with a new technique: slicing.

Slicing allows you to extract a portion of a list. Starting and stopping indexes are separated by a colon : 

animals = ["Dog", "Cat", "Bird", "Fish"]
#extracts Cat and Bird
animals[1:3]

animals = ["Dog", "Cat", "Bird", "Fish"]
#extracts Cat, Bird and Fish
animals[1:4]
#Displays ["Cat", "Bird", "Fish"]
print(animals[1:4])

The starting index is inclusive. The stopping index is exclusive.
i.e. The last number is excluded, the first is included, and anything in between the two is included.

Slicing also works with strings.

You can use indexing and slicing on lists and strings, because they are ordered sequences.

vehicle = "airplane"
#prints air
print(vehicle[0:3])

Slicing a list produces another list.

colors = ['red', 'green', 'blue', 'yellow']
#prints ['blue']
print(colors[2:3])

Slicing a string produces another string

fruit = "orange"
#prints or
print(fruit[0:2])

When slicing, you can omit the starting index. This means that you'll be slicing from the very first element.

cart = ['lamp', 'candles', 'chair', 'carpet']
print(cart[:3])

When slicing, you can omit the stopping index. This means that you'll be slicing until the very last element.

cart = ['lamp', 'candles', 'chair', 'carpet']
print(cart[1:])

You can also omit all indexes to just take the whole list/string.

vehicle = 'motorbike'
print(vehicle[:])

NEGATIVE INDEXING

Python supports "indexing from the end", called negative indexing. This means the last value of a sequence has an index of -1.

Cat Dog Fox Cow
-4  -3  -2  -1

animals =["cat", "dog", "bird", "cow"]
print(animals[-1]) # Last element
print(animals[-2]) # Second last element
print(animals[-3:]) # Last 3 elements
print(animals[-3:-1]) 

In indexing from the end, you start with the smallest number.

You can combine positive with negative indexing when slicing.

c = ['A', 'B', 'C', 'D']
#Displays ['B', 'C']
print(c[1:-1])

c = ['A', 'B', 'C', 'D']
c[:2] = ['E', 'F']
#Display ['E', 'F', 'C', 'D']
print(c)

FUNCTIONS

Functions are reusable blocks of code for specific tasks. 
They help keep your code as short and easy to work with as possible, saving you from repeating code.
A function performs a task. 

print(), input(), range(), and type() are functions.

A function contains the code to perform a task. To use this code, you just need to CALL the function.

Every function has a name. The code within a function is only executed when the function is called.

The same function can be called multiple times.

Functions require information to be passed in order for the task to be completed. 
We pass information into functions as ARGUMENTS.

Arguments go inside parenthesis ().

For instance, when we add "New Message" to the print() function, we PASS THE ARGUMENT.

print("New Message")

In this example print() is the NAME of the function, and "New Message" the an ARGUMENT.

Functions need their arguments to work. Missing arguments can result in errors.

A function can take multiple arguments.

For example, we can pass multiple arguments to the print() function to display multiple values in one line.

print("Your seat:", 4)

That example has two arguments.

The print function can take arguments from different data types.

Multiple arguments in a function are separated with a comma.

print() and range() are examples of built-in functions. 
Python has many built-in functions which you can re-use in your code by calling them.

Built-in functions like print() and range() are blocks of code created by others to do specific things. 
This simplifies the code a lot, as you don’t need to rewrite the code each time. All you need to do is to call them!

Functions can take operations as arguments. 

As an example, the print() function can accept math, logical and comparison operations.

print(55 * 3) #math
print(5 > 7) #comparison
print(True and False) #logical
print("motor" + "bike") #concatenation

Different functions accept different types of arguments. For example, the range() function accepts only integers.

You can use values stored in variables as arguments.

balance = 304
print("Money in account:", balance)

A function can be an argument for another function.

print(type("word"))
print(range(3))

int(), str(), and float() instructions are functions used for data conversion.

Your code will result in errors if you pass the incorrect data type as an argument. 
Some functions require specific data types as arguments.

For example, the int() function won't be able to convert non-numeric characters (e.g. a–z) into numbers and it'll result in an error.



CONCATENATION vs DISPLAYING SEVERAL ARGUMENTS

element = "air"
vehicle = "plane"
print(element + vehicle) #Displays airplane
print(element, vehicle) #Displays air plane

STRING FUNCTIONS

Correctly handling text data is a key skill all coders need to master. 
String functions will enhance your productivity when working with text.

STRING FUNCTIONS / UPPER (),  LOWER ()

The functions upper() and lower() allow you to quickly change the case of a string to all in uppercase or lowercase, respectively.

print('SmArTpHoNe'.lower()) #Displays smartphone
print('SmArTpHoNe'.upper()) #Displays SMARTPHONE

brand = ikea
print(brand.upper()) #Displays IKEA

upper() and lower() functions can only be used on strings. 

Functions that only work on certain objects (strings, lists, etc.) are called using dot . notation.

STRING FUNCTIONS / CAPITALIZE()

The capitalize() function will save you time when you need to convert the first character of a string to uppercase, 
while making the remaining characters lowercase.

print("happy birthday".capitalize()) #Displays Happy birthday

name = JAMES
print(name.capitalize()) #Displays James

Strings are immutable and functions won't change them. You'll need to store the modified string in a variable to keep it.

item = "smartwatch"
item2 = item.upper()

#Error because strings are immutable
item = upper(item)
print(item)

STRING FUNCTIONS / FIND()

The find() function checks if a character (or a pattern of characters) is present in a string. 
The function returns the index (position) of the given value. 
If the given value is present multiple times, the function will return the first occurrence (the lowest index).

print("Bee".find("e")) #Displays 1 because that's the index of the first e letter

The find() function applies to a string so you call it using dot notation.

find() will return an error if you don't include an argument between the parentheses. 
With nothing to look for in the string, the function can't do its job.
This won't happen with upper(), lower() and capitalize(). They don't need any more information to complete their task.

'roBot'.find() # error
'roBot'.upper() # no error

find() will return -1 if the value can't be found in the string.

print("robot".find("A")) #Displays -1 because there are no As in the string "robot"

The argument inside find() is case-sensitive.

print('roBot'.find("b")) #Displays -1 because there's no lowercase b in "roBot"
print('roBot'.find("B")) #Displays 2 because that's the index of the uppercase B in "roBot"
print('roBot'.lower().find("b")) #Displays 2 because lower() put everything in lowercase
print('roBot'.find("B" or "b")) #Displays 2 because you can use the "or" logical operation inside a find()

LIST FUNCTIONS

In this lesson you'll learn to use built-in list functions.

LIST FUNCTIONS / LEN()

len() is one of the most useful built-in functions.

len() stands for length and, when used on lists, it returns the number of items in the list.

movies = ["Avatar", "Titanic", "Avengers"]
print(len(movies)) #Display 3

The len() function is not only for lists. It accepts as an argument any sequence, including strings.

movie = "Avatar"
print(len(movie)) #Display 6

len() is a very useful function that accepts a wide range of arguments. 
It’s not specific to a any particular data type or object, so you don’t use dot notation to call it.

LIST FUNCTIONS / APPEND()

The append() function adds a new item to the end of a list. 
append() is called using dot notation because it’s specific to lists.

songs = ["Yesterday", "Hello", "Believer"]
songs.append("Imagine")
print(songs) #Display ['Yesterday', 'Hello', 'Believer', 'Imagine']

The append() function is for lists. If you try to use append() on a string you’ll get an error. 
This happens because strings are immutable.

LIST FUNCTIONS / INSERT()

The insert() function allows you to add an element to a list, at a specific position.

items = ["book", "pen", "pencil"]
items.insert(2,"marker")
print(items) #Display ['book', 'pen', 'marker', 'pencil']
print(items[2]) #Display marker

insert() takes 2 arguments. The first is the index (where to insert) and the second is the item (what to insert).

LIST FUNCTIONS / POP()

The pop() function removes an element from a list.
That position indicated by the index is the only argument that the pop() function accepts.

items = ["book", "pen", "pencil"]
items.pop(1) #Removes "pen" from the list
print(items)
print(items[1])

CUSTOM FUNCTIONS / def

Built-in functions can save you a lot of work, but you’ll also need to create your own custom functions to solve specific tasks.

A function is a reusable block of code.

To use your own functions, you need to DEFINE them first.  

Once a function has been defined, you can CALL it as many times as you need.

The greet() function below contains code to display a nice message when called

#function definition
def greet():
  print("Hello from a function")
  print("Have a great day")
#function call
greet()

Use def followed by a name to define a new function

The BODY of a function contains the reusable code that is executed when the function is called. 
The code for the body of a function must be indented.

When a function is defined, you need to make sure parentheses () are added after the name. 
A colon : must be added at the end of the definition line.

You can define functions that take any number of arguments (including zero).  
Arguments are put inside the parentheses () following the function name.

A function might require arguments to complete its tasks. 
Arguments are put inside the parentheses () following the function name.

#function definition
def personal_greet(name): 
  print("Hello", name)
  print("Have a great day")

#function calls
personal_greet("Sarah") 
personal_greet("Henry")
personal_greet(input())

#Define the function
def double(number):
    print(number*2)

#Call the function
double(6) #Displays 12

Functions must be defined before they can be called. 

weight = 73
height = 1.5

#Defines function
def bmi_calculator(weight, height):
    bmi = weight / height **2
    print(bmi)

#Calls function
bmi_calculator(weight, height)

When calling a function, you need to use the same number of arguments that have been defined, in the same order.

When you have a variable inside a function, it's a LOCAL VARIABLE.

Local variables are not accessible outside the function.

RESULT

A return statement in a function is used to specify the value that the function should produce when it is called.

The return statement does not set the value of the function itself; rather, it determines the output of the function. 

Once a return statement is encountered, the function exits, and the specified value is returned to the caller. 

This returned value can be directly used, assigned to a variable, or involved in further operations in the calling code.

This code will print 32.444:

weight = 73
height = 1.5

def bmi_calculator(weight, height):
    bmi = weight / height ** 2
    return bmi
    
print(bmi_calculator(weight, height))

This code will print None:

weight = 73
height = 1.5

def bmi_calculator(weight, height):
    bmi = weight / height ** 2
    
result_bmi_calculator = bmi_calculator(weight, height)

print(result_bmi_calculator)

This is because without the return statement, the function returns no value.

Another example: this will print the final grade because there's a return statement.

exam_1 = 6.5
exam_2 = 9

def calculate_grade(exam_1, exam_2):
    final_grade = (exam_1 +exam_2)/2
    return final_grade
    
print(calculate_grade(exam_1, exam_2))
